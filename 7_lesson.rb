# Анонимные методы
3.times { |i| puts i }

[1, 2, 3, 4].each { |i| puts i * 10 }

# Чтение построчно
line_num = 0
File.open("name_file").each do |line|
  puts "#{line_num += 1}: #{line}"
end
# Откроет фаил, прочитает его построчно и закроет

# чтобы сохранить блок в переменную
a = Proc.new { |x| x = x * 10; puts x }
# или
b = proc { |x| x = x * 10; puts x }
# или
c = lambda { |x| x = x * 10; puts x }

# затем что бы вызвать его исполнение:
a.call(100)

# в "a" и "b" нет проверки на кол-во передаваемых аргументов а "с" есть

# Работа с блоком в методе:
def m
  puts "111"
  yield # Вызов блока!
  puts "222"
end
# вызываем метод:
m { puts "1.5"}

# ИЛИ - Работа с блоком в методе:
def m(str)
  puts "111"
  yield(str) # Вызов блока!
  puts "222"
end
# вызываем метод:
m("string") { |str| puts str[0] }

# Передеать блок как именнованный аргумент
def m(str, block)
  puts "111"
  block.call(str) # Вызов блока!
  puts "222"
end
# сам блок
block = lambda { |x| puts x }
# вызываем метод:
m("string", block) # возможно без скобок

# ИЛИ!
def m(str, &block) Обязательно блок идет последним и с &
  puts "111"
  block.call(str) # Вызов блока! В данном случае можно использовать yield(str)
  puts "222"
end
# вызываем метод:
m("string") { |x| puts x }

# Если блок опциональный:
if block_given?
  # это в методе если блок передан, то зайдем сюда
end

# Запись ->(x) { puts x } это то же самое, что и lambda { |x| puts x }, только короче. Если встретите такую запись, не пугайтесь, это всего лишь lambda.
